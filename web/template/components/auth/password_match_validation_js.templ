package auth


var PasswordMatchValidationJSHandle = templ.NewOnceHandle()

templ PasswordMatchValidationJS2() {
@PasswordMatchValidationJSHandle.Once(){

<script>
    document.addEventListener('DOMContentLoaded', function () {
        const passwordInput = document.getElementById('password-input');
        const confirmPasswordInput = document.getElementById('confirm-password-input');
        const confirmPasswordErrorElement = document.getElementById('confirm-password-error');
        const confirmPasswordContainer = document.getElementById('confirm-password-container')


        const successBorderClass = "border-success"
        const errorBorderClass = "border-error"

        if (!passwordInput || !confirmPasswordInput || !confirmPasswordErrorElement) {
            console.warn('Password match validation: One or more required elements not found.');
            return;
        }

        function validatePasswordsMatch() {


            confirmPasswordContainer.classList.remove(successBorderClass, errorBorderClass);

            if (confirmPasswordInput.value === "") {
                confirmPasswordErrorElement.textContent = "";
                confirmPasswordInput.setCustomValidity("");
                return;
            }

            if (passwordInput.value !== confirmPasswordInput.value) {
                confirmPasswordErrorElement.textContent = "Passwords do not match.";
                confirmPasswordInput.setCustomValidity("Passwords do not match.");
                confirmPasswordContainer.classList.add(errorBorderClass)

            } else {
                confirmPasswordErrorElement.textContent = "";
                confirmPasswordInput.setCustomValidity("");
                confirmPasswordContainer.classList.add(successBorderClass)
            }
        }

        confirmPasswordInput.addEventListener('blur', validatePasswordsMatch);


        passwordInput.addEventListener('input', function () {
            if (confirmPasswordInput.value !== "") {
                validatePasswordsMatch();
            } else {
                confirmPasswordErrorElement.textContent = "";
                confirmPasswordInput.setCustomValidity("");
                confirmPasswordContainer.classList.remove(successBorderClass, errorBorderClass);
            }
        });


        confirmPasswordInput.addEventListener('focus', function () {
            confirmPasswordContainer.classList.remove(successBorderClass, errorBorderClass);
        })
    });
</script>

}
}

templ PasswordMatchValidationJS() {
@PasswordMatchValidationJSHandle.Once(){

<script>
    function initializePasswordVisibilityToggles(parentElement) {
        // Find buttons within the specific parentElement
        const togglePasswordButtons = parentElement.querySelectorAll('.toggle-password-visibility');

        togglePasswordButtons.forEach(button => {
            // Prevent re-attaching listeners if already initialized on this specific button
            if (button.dataset.viewPasswordInitialized === 'true') {
                return;
            }

            const targetInputId = button.dataset.targetInput;
            if (!targetInputId) {
                console.warn('ViewPasswordJS: Button is missing data-target-input attribute:', button);
                return;
            }

            // Query for the input within the same parentElement context
            const passwordInput = parentElement.querySelector('#' + targetInputId);

            const eyeIcon = button.querySelector('.eye-icon');
            const eyeSlashIcon = button.querySelector('.eye-slash-icon');

            if (passwordInput && eyeIcon && eyeSlashIcon) {
                button.addEventListener('click', function () {
                    const type = passwordInput.getAttribute('type') === 'password' ? 'text' : 'password';
                    passwordInput.setAttribute('type', type);

                    // Simple toggle based on the new type
                    if (type === 'text') {
                        eyeIcon.classList.add('hidden');
                        eyeSlashIcon.classList.remove('hidden');
                    } else {
                        eyeIcon.classList.remove('hidden');
                        eyeSlashIcon.classList.add('hidden');
                    }
                });
                button.dataset.viewPasswordInitialized = 'true'; // Mark as initialized
            } else {
                if (!passwordInput) console.warn('ViewPasswordJS: Could not find password input with ID:', targetInputId, 'for button:', button, 'within parent:', parentElement);
                if (!eyeIcon) console.warn('ViewPasswordJS: Could not find .eye-icon in button:', button);
                if (!eyeSlashIcon) console.warn('ViewPasswordJS: Could not find .eye-slash-icon in button:', button);
            }
        });
    }

    // Initial setup on DOMContentLoaded
    document.addEventListener('DOMContentLoaded', function () {
        initializePasswordVisibilityToggles(document.body);
    });

    // HTMX event to re-initialize after content swap
    document.body.addEventListener('htmx:afterSwap', function (event) {
        // event.detail.elt is the element that htmx swapped into the DOM
        // Initialize interactions on the newly swapped content or its relevant container
        if (event.detail.elt) {
            initializePasswordVisibilityToggles(event.detail.elt);
        }
    });

</script>
}
}