package auth


var ViewPasswordJSHandle = templ.NewOnceHandle()

templ ViewPasswordJS2() {
@ViewPasswordJSHandle.Once(){

<script>
    document.addEventListener('DOMContentLoaded', function () {
        const togglePasswordButtons = document.querySelectorAll('.toggle-password-visibility');

        togglePasswordButtons.forEach(button => {
            const targetInputId = button.dataset.targetInput; // Get the target input's ID from the data attribute

            if (!targetInputId) {
                console.warn('Button is missing data-target-input attribute:', button);
                return;
            }

            const passwordInput = document.getElementById(targetInputId);

            const eyeIcon = button.querySelector('.eye-icon');
            const eyeSlashIcon = button.querySelector('.eye-slash-icon');

            if (passwordInput && eyeIcon && eyeSlashIcon) {
                button.addEventListener('click', function () {
                    const type = passwordInput.getAttribute('type') === 'password' ? 'text' : 'password';
                    passwordInput.setAttribute('type', type);

                    if (type === 'text') {
                        eyeIcon.classList.add('hidden');
                        eyeSlashIcon.classList.remove('hidden');
                    } else {
                        eyeIcon.classList.remove('hidden');
                        eyeSlashIcon.classList.add('hidden');
                    }
                });
            } else {
                if (!passwordInput) console.warn('Could not find password input with ID:', targetInputId, 'for button:', button);
                if (!eyeIcon) console.warn('Could not find .eye-icon in button:', button);
                if (!eyeSlashIcon) console.warn('Could not find .eye-slash-icon in button:', button);
            }
        });
    });
</script>


}
}



templ ViewPasswordJS() {
@ViewPasswordJSHandle.Once(){

<script>
    function initializePasswordMatchValidation(parentElement) {
        // Scope selectors to the parentElement
        const passwordInput = parentElement.querySelector('#password-input');
        const confirmPasswordInput = parentElement.querySelector('#confirm-password-input');
        const confirmPasswordErrorElement = parentElement.querySelector('#confirm-password-error');
        const confirmPasswordContainer = parentElement.querySelector('#confirm-password-container');

        const successBorderClass = "border-success";
        const errorBorderClass = "border-error";

        // If any of these critical elements are missing within the parentElement, don't proceed for this scope
        if (!passwordInput || !confirmPasswordInput || !confirmPasswordErrorElement || !confirmPasswordContainer) {
            // console.warn('PasswordMatchJS: One or more required elements not found within parent:', parentElement);
            return;
        }

        // Prevent re-attaching listeners if already initialized on these specific inputs
        if (confirmPasswordInput.dataset.matchValidationInitialized === 'true') {
            // console.log('PasswordMatchJS: Match validation already initialized for confirmPasswordInput in parent:', parentElement);
            return;
        }


        function validatePasswordsMatch() {
            confirmPasswordContainer.classList.remove(successBorderClass, errorBorderClass);
            if (confirmPasswordInput.value === "") {
                confirmPasswordErrorElement.textContent = "";
                confirmPasswordInput.setCustomValidity("");
                return;
            }
            if (passwordInput.value !== confirmPasswordInput.value) {
                confirmPasswordErrorElement.textContent = "Passwords do not match.";
                confirmPasswordInput.setCustomValidity("Passwords do not match.");
                confirmPasswordContainer.classList.add(errorBorderClass);
            } else {
                confirmPasswordErrorElement.textContent = "";
                confirmPasswordInput.setCustomValidity("");
                confirmPasswordContainer.classList.add(successBorderClass);
            }
        }

        confirmPasswordInput.addEventListener('blur', validatePasswordsMatch);
        // confirmPasswordInput.addEventListener('input', validatePasswordsMatch); // Optional

        passwordInput.addEventListener('input', function () {
            if (confirmPasswordInput.value !== "") {
                validatePasswordsMatch();
            } else {
                confirmPasswordErrorElement.textContent = "";
                confirmPasswordInput.setCustomValidity("");
                confirmPasswordContainer.classList.remove(successBorderClass, errorBorderClass);
            }
        });

        confirmPasswordInput.addEventListener('focus', function () {
            confirmPasswordContainer.classList.remove(successBorderClass, errorBorderClass);
        });

        // Mark as initialized to prevent duplicate listeners from parent calls
        confirmPasswordInput.dataset.matchValidationInitialized = 'true';
        // Note: passwordInput's listener might be re-added if it's outside a swapped confirmPasswordInput's parent,
        // but its effect is idempotent on validatePasswordsMatch.
    }

    // Initial setup on DOMContentLoaded
    document.addEventListener('DOMContentLoaded', function () {
        initializePasswordMatchValidation(document.body);
    });

    // HTMX event to re-initialize after content swap
    document.body.addEventListener('htmx:afterSwap', function (event) {
        // event.detail.elt is the element that htmx swapped into the DOM
        if (event.detail.elt) {
            initializePasswordMatchValidation(event.detail.elt);
        }
    });
</script>

}
}